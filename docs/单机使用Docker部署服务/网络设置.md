# 网络设置

通常我们的服务都是为了让外部访问的,在上面的例子中我们虽然将服务启动了但外部并没有办法访问.本文将介绍单机环境下的Docker网络配置.

Docker中网络配置是专门的一块.使用`docker networks`子命令管理.

单机条件下可用的网络驱动有两种:

+ `bridge`也就是桥接网络,也是docker容器在单机环境下的默认网络类型.
+ `host`也就是完全映射宿主机的网络
+ `none`关闭容器的网路功能

## bridge网络

`bridge`驱动会为每一个容器分配,设置IP等网络相关资源,并将容器连接到一个`docker0`虚拟网桥.通过`docker0`网桥以及`Iptables nat表`配置与宿主机以及其他容器通信.

### 与宿主机通信

与宿主机通信可以分为两段:

1. 服务中的容器访问宿主机上的端口

1. 宿主机访问服务的端口

#### 容器访问宿主机

容器要访问宿主机上的端口根据不同的安装环境有两种方式:

+ 如果是windows或者mac平台使用的`docker desktop`运行的docker服务,那么可以在容器种使用`host.docker.internal`作为hostname代表宿主机.
+ 如果是linux下直接安装的docker,则可以直接使用本机的内网ip作为hostname在容器种使用.

我们在`app.py`的代码中通过获取环境变量`REDIS_URL`来这是连接的redis的路径.在`docker-compose.yml`中我们则是通过`environment`字段来设置环境变量`REDIS_URL`的值.

我们使用`host.docker.internal`指代宿主机的hostname,这样就可以访问到redis了.

#### 宿主机访问服务

`bridge`网络模式通过设置`ports`字段声明对外暴露的端口,其形式为`HOST:CONTAINER`:

```yml
ports:
  - "3000" # 容器的3000端口映射到宿主机的相同端口
  - "5000:4000" # 容器的4000端口映射为宿主机的5000端口
  - "6060:6050/udp" # 容器udp网络协议的6050端口映射为宿主机的6060端口
```

### 容器间互联

容器间互联可以分为相同服务栈内容器的互联和不同服务栈内容器的互联.

#### 相同服务栈内容器的互

单机情况下我们部署服务栈时会默认创建一个名为`<服务栈名>_default`的bridge网络.我们也可以在服务栈中使用`networks`来申明一个bridge网络,然后在需要的服务中使用它.

在我们的程序中,只需要将hostname设置为同服务栈下的服务名即可.

#### 不同服务栈内容器的互联

实际上我们只要访问`webapp`,并不关心它是存在哪个redis里,更加不会没事取访问它依赖的那个redis.类似的情况很多,况且暴露越多的端口也越危险.

`bridge`网络无法访问宿主机的端口,因此常见的用法是将依赖的服务放到同一个stack,在同一个stack下会默认创建一个网络,同一个stack中的service都可以使用service的名字作为hostname相互访问.

> 例6: [上例stack中的redis不再暴露给外网](https://github.com/hsz1273327/TutorialForDocker/tree/helloworld-with-redis-connect)

```yml
version: "2.4"
services:
  redis: 
    image: redis:latest
  webapp:
    ...
    environment: 
      REDIS_URL: "redis://redis:6379"
    ...
```
我们只需要将redis暴露的端口去掉,并且使用`redis`作为redis连接的hostname.




## host网络

单机下最方便的就是使用`host`网络,它会像在本地开发一样的和宿主机共享网络端口,其配置方法就是在`service`中使用`network_mode`声明使用`host`网络:

```yml
network_mode: "host"
```

当然这种方式也是相当危险的,它无异于将本机的所有端口暴露给了容器,如果是不熟悉来源的容器建议不要使用这种方式.
需要注意由于docker desktop的实现问题,在windows和mac下这个方式并不会起任何效果,也就是说只在linux下会生效.由于多数人还是在windows/mac下做开发,因此这种方式其实实用性不高.
