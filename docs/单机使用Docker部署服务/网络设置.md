
## 网络配置

上面的例子中我们部署了一个nginx,nginx是一个静态http服务器和网络代理中间件,如果按上面的方式部署我们肯定是无法使用它的,因为很明显容器既无法让外部访问到,也无法访问外部的环境.

docker中网络配置是专门的一块.本文是介绍单机上docker部署的,因此这部分也只介绍单机条件下的网络配置.

单机条件下可用的网络驱动有两种:`host`也就是完全映射宿主机的网络,`bridge`也就是桥接网络.

### host网络

单机下最方便的就是使用`host`网络,它会像在本地开发一样的和宿主机共享网络端口,其配置方法就是在`service`中使用`network_mode`声明使用`host`网络:

```yml
network_mode: "host"
```

当然这种方式也是相当危险的,它无异于将本机的所有端口暴露给了容器,如果是不熟悉来源的容器建议不要使用这种方式.
需要注意由于docker desktop的实现问题,在windows和mac下这个方式并不会起任何效果,也就是说只在linux下会生效.由于多数人还是在windows/mac下做开发,因此这种方式其实实用性不高.

### bridge网络

`bridge`网络相对就安全许多.`bridge`网络是单机模式下的默认网络驱动,它无法直接访问宿主机的端口,而要让容器外部访问到容器内的端口也需要使用`ports`字段声明,其形式为:

```yml
ports:
  - 3000:3000
```

其中冒号左侧的是映射到宿主机的端口,右侧的则是要映射的容器中的端口.

> 例3: [将nginx中的80端口映射到宿主机的8080端口](https://github.com/hsz1273327/TutorialForDocker/tree/example-nginx-ports)

```yml
version: "2.4"
services:
  http_static:
    ...
    ports: 
      - "8080:80"
    ...
```

相对应的另一种需求是我们希望容器可以访问宿主机上的服务.

+ 如果是windows或者mac平台使用的`docker desktop运行的docker服务`,那么可以在容器种使用`host.docker.internal`作为hostname代表宿主机.
+ 如果是linux下直接安装的docker,则可以直接使用本机的内网ip作为hostname在容器种使用.

> 例4: [使用`bridge`网络部署sanic应用,并连接本地的redis(windows或mac下)](https://github.com/hsz1273327/TutorialForDocker/tree/helloworld-with-redis)

这里例子我们要起两个服务,一个是sanic的http服务(helloworld例子的扩展),一个是redis.我们的sanic需要访问redis的`foo`这个key,为其设置值和取值.

+ `app.py`

  ```python
  from sanic.response import json
  from sanic import Sanic
  from aredis import StrictRedis
  import os
  redis_url = os.environ.get(f"REDIS_URL") or "redis://localhost:6379"
  app = Sanic("hello_example")
  client = StrictRedis.from_url(redis_url,decode_responses=True)

  @app.get("/")
  async def test(request):
      return json({"hello": "world"})

  @app.get("/set_foo/<value:string>")
  async def set(request,value):
      await client.set('foo', value)
      return json({"result": "ok"})

  @app.get("/get_foo")
  async def get(request):
      res = await client.get('foo')
      return json({"result":res})

  if __name__ == "__main__":
      print(f"redis_url: {redis_url}")
      app.run(host="0.0.0.0", port=5000)
  ```

+ `docker-compose.yml`

  ```yml
  version: "2.4"
  services:
    redis: 
      image: redis:latest
      ports:
        - "5379:6379"
    webapp:
      build: ./
      logging:
        driver: "json-file"
        options:
          max-size: "200k"
          max-file: "10"
      ports:
        - "5000:5000"
      environment: 
        REDIS_URL: "redis://host.docker.internal:5379"
      cpus: 1.0
      mem_limit: 30m
      restart: on-failure
  ```

我们在`app.py`的代码中通过获取环境变量`REDIS_URL`来这是连接的redis的路径.在`docker-compose.yml`中我们则是通过`environment`字段来设置环境变量`REDIS_URL`的值.

我们使用`host.docker.internal`指代宿主机的hostname,这样就可以访问到redis了.



### 使用bridge网络联通服务

实际上我们只要访问`webapp`,并不关心它是存在哪个redis里,更加不会没事取访问它依赖的那个redis.类似的情况很多,况且暴露越多的端口也越危险.

`bridge`网络无法访问宿主机的端口,因此常见的用法是将依赖的服务放到同一个stack,在同一个stack下会默认创建一个网络,同一个stack中的service都可以使用service的名字作为hostname相互访问.

> 例6: [上例stack中的redis不再暴露给外网](https://github.com/hsz1273327/TutorialForDocker/tree/helloworld-with-redis-connect)

```yml
version: "2.4"
services:
  redis: 
    image: redis:latest
  webapp:
    ...
    environment: 
      REDIS_URL: "redis://redis:6379"
    ...
```
我们只需要将redis暴露的端口去掉,并且使用`redis`作为redis连接的hostname.