# 镜像构建优化

我们上面已经介绍过如何使用dockerfile构建镜像了,但这只能算是个helloworld级别的东西.本文将从实用角度出发介绍如何加快镜像构建,减小镜像大小,构建更加易于维护的镜像,并从原理的角度解释为什么.

由于编译语言和解释语言在docker下的优化思路有较大不同,因此本文的例子有两个,也就是针对之前的python版本和golang版本进行优化.

+ [python版本]()
+ [golang版本]()

## 加快镜像构造

一个docker镜像的一个开发周期一般是

1. 构造Docker镜像
2. 调试镜像
3. 更改代码,然后重新构建Docker镜像.
4. 重复第二步和第三步直至满足需求

如果可以减少构建镜像的时间那么开发工作将会更加高效.

加快镜像构造有两种思路:

1. 优化`dockerfile`,通过合理的编排dockerfile中的命令提高镜像的执行效率
2. 优化`docker build`,通过更换build工具提高镜像构造效率

这两种思路都有可以优化的空间.

### 优化`dockerfile`

优化`dockerfile`的核心思想在充分利用缓存,在构建镜像的过程中每一行`ADD`,`COPY`,`VOLUME`,`RUN`都会被缓存并构建为一层`layer`,如果中间某一行有变化而无法使用缓存了那么其后的所有缓存都将失效.因此我们应该在满足需求的情况下将修改可能性低的放在前面,修改可能性高的放在后面.

比如go版本的例子中一般来说依赖项比代码修改的可能性低,所以因该将`ADD go.mod /code/go.mod`放在`ADD main.go /code/main.go`

在这一思路下,我们甚至可以将确定不变或者少变化的部分直接先打包为基镜像,然后开发应用的时候再从这个基镜像开始构建.比如我们知道`uvloop`基本是python异步编程的必装库,而且因为它是`c`扩展,很多平台都需要现编译因此构建极慢,而且这个库已经基本稳定了,因此就可以先为它构建镜像,然后基于它再构建镜像.这个策略在解释型语言的构建过程中非常常见.

针对`ADD`和`COPY`,我们应该细颗粒度的只将构建需要的文件放入Dockerfile而不是将整个工程文件夹放入,因为一方面工程文件夹中的`.git`等文件夹的变动一样会引起缓存失效,另一方面也可以避免缓存溢出.

针对`RUN`,我们应该将`依赖的更新,安装,删除缓存`放在同一层.这虽然会造成每次修改都整体重装,但避免了因为缓存保留过时依赖,而且可以减小镜像大小.综合考虑是划得来的.

我们可以大致给出一个stage中的结构顺序(没有就不填):

```dockerfile
FROM 基镜像
ENV 环境变量
WORKDIR 工作文件夹
ADD/COPY 依赖文件
RUN 安装依赖
ADD/COPY 程序文件
RUN 编译程序
HEALTHCHECK 健康检查
CMD/ENTRYPOIT 执行命令
```

### 优化`docker build`

docker默认的`docker build`(下面用`旧版`指代)在功能上已经可以满足需求了,但性能比较差,我们可以使用[moby/buildkit](https://github.com/moby/buildkit)来代替,目前这只是一个可选项,我们需要在设置中添加`"features": { "buildkit": true }`来替换旧版.

`buildkit`对比旧版主要的优化在如下几个方面:

1. 旧版对Dockerfile指令执行构建步骤是顺序执行的,在单阶段构建的情况下这不是问题,但在多阶段构建情况下这就会造成性能浪费延长构建时间,因为相当于会顺序的执行全部步骤.而`buildkit`会为多阶段构建创建一个依赖树,构建时只会执行用到的阶段,一些可以并行的阶段也会被并行构建.
2. 优化了缓存机制,`buildkit`的缓存更加高效

事实上我们前面用的buildx也是基于`buildkit`的实现.

## 最小化镜像构建

首先说两个容易造成误判的点:

> "alpine构造的镜像小所以占用宿主机空间小,拉取镜像也会快"

这个说法并不全对但也不全错.镜像的原理我们在前文中已经有介绍,镜像是层层叠加的,因此无论是保存还是拉取都是一个增量修改而非全量修改,每次的增量一般就是代码变动的部分.因此除了第一次拉取会因为镜像总体大小有较大差别外,一般使用并不会有什么差别

> "alpine体积小,依赖少,所以启动起来更快"

并不是.容器的启动非像正常Linux启动哪样要启动一堆的服务.无论镜像的体积多大,依赖多少都不会启动多余的东西,自然不会更慢.

那为什么要追求最小化镜像呢?

1. `安全考虑`:镜像越小攻击范围越小
2. `首次部署`:上面说过总体看镜像大小并不会有太大影响,但首次部署时影响却相当大,比如我们要将一个系统迁移至另一个docker环境,这相当于需要拉取整个系统的镜像,如果网络不好可能一部署就是一整天.首次部署决定了系统的迁移成本.

最小化镜像构建的思路一样可以分为两种:

1. 优化`dockerfile`,通过合理的编排dockerfile中的命令减小镜像大小
2. 优化`基镜像`,通过合理的选择基镜像来减小镜像大小

### 优化`dockerfile`

优化`dockerfile`的核心思想是减少文件引入.具体来说有如下几点:

1. 只安装执行必须的依赖

    不要安装调试工具,如果实在需要调试工具,可以在容器运行之后再进入容器中安装.某些包管理工具(如`apt`)除了安装用户指定的包之外还会安装推荐的包,这会无缘无故增加镜像的体积.`apt`可以通过添加参数`-–no-install-recommends` 来确保不会安装不需要的依赖项.

2. 删除依赖缓存

    镜像并不需要缓存,我们应该安装时避免使用缓存,下面是常见的避免缓存的语句.

    | 环境            | 语句                         |
    | --------------- | ---------------------------- |
    | `python`        | `pip --no-cache-dir install` |
    | `dedian/ubuntu` | `apt-get clean`              |
    | `node`          | `npm cache clean --force`    |

    这通常对于解释型语言减少镜像大小会比较有用

3. 使用多阶段构建

    针对编译型语言我们可以分阶段构建镜像,将独立的可执行文件在一个阶段编译出来,之后放入干净的执行环境.

### 优化`基镜像`

首先我们看下有哪些可选的系统镜像

+ `scratch`,本质上这不是一个镜像,它的含义是`空`,因此不能被`pull`,也不能运行.这就意味着新镜像的构建是从零开始,不存在其他的镜像层.它有如下缺点点:
    1. 缺少`shell`,因此用它就告别`shell模式`的`CMD`或者`ENTRYPOINT`指令了,当然了它还是可以使用`exec模式`执行我们放进去的可执行文件的.

    2. 缺少`glibc`,因此所有依赖动态链接库的程序都无法使用,这也就意味着我们必须将可执行文件编译为静态.下面是常见编译型语言编译为静态(不依赖`libc`)的设置

        | 语言     | 命令位置                                                   | 命令                                                               |
        | -------- | ---------------------------------------------------------- | ------------------------------------------------------------------ |
        | `C/C++`  | `gcc/g++ -o hello hello.c -static`                         | 命令行                                                             |
        | `golang` | `CGO_ENABLED=0`                                            | 环境变量                                                           |
        | `rust`   | `cargo build --release --target=x86_64-unknown-linux-musl` | 命令行,需要先`rustup target add x86_64-unknown-linux-musl`安装工具 |

    3. 缺少调试工具,`shell`都没有,什么`ls`,`cp`自然也都没有,更不要提什么`curl`了,因此健康检测就不要想了

    符合以下特点的可执行文件适合放到这个基镜像下:
    + 静态可执行文件
    + 不需要健康检测

+ [busybox](https://registry.hub.docker.com/_/busybox),本质上是一个linux集成开发环境,它有shell,集成了最常用的100多种工具,但是没有包管理.他有3种版本:
    + `uclibc`版本,tag中带有`uclibc`的版本,大小在`700k左右`
    + `musl`版本,tag中带有`musl`的版本,大小在`800k到900k`,额外集成了`musl libc`
    + `glibc`版本,tag中带有`glibc`的版本,大小在`2m到3m`,额外集成了`glibc`

    符合以下特点的可执行文件适合放到这个基镜像下:
    + 静态可执行文件,如果使用的是`glibc`版本,那么我们可以使用基于`glibc`动态库的可执行文件
    + 需要shell
    + 需要常用调试工具
    + 不需要包管理

+ [alpine](https://registry.hub.docker.com/_/alpine),`2m到3m`的大小.前文已经介绍过,这边不再复述,本质上可以理解为`busybox:musl`+`apk`.符合以下特点的可执行文件适合放到这个基镜像下:
    + 静态可执行文件或者依赖`musl libc`的可执行文件,如果要使用基于`glibc`动态库的可执行文件,需要额外安装`build-base`这个工具集
    + 需要shell
    + 需要包管理工具安装工具
    + 需要完整操作系统

+ [Debian-slim](https://registry.hub.docker.com/_/debian),这个连接给出的是`Debian`的镜像仓库,而`Debian-slim`专指其tag部分有`slim`标识的镜像,这就是一个精简版`Debian`,`25m左右`的大小也足够精简,它的优势是它是`Debian`,可以使用完整的`Debian`生态.

#### 编译型语言的基镜像选择

编译型语言我们通常都是使用多步骤构建,这里给出的建议是

编译可执行文件的步骤:

1. 尽量构建纯静态的可执行文件.
2. 使用官方给出的基镜像,比如`golang:1.15`这样

构造镜像的步骤:

可以参考下面的矩阵图

| ---              | 需要健康检测  | 不需要健康检测  |
| ---------------- | ------------- | --------------- |
| 静态可执行文件   | `alpine`      | `scratch`       |
| 非静态可执行文件 | `Debian-slim` | `busybox:glibc` |

#### 解释型语言的基础镜像选择

解释型语言一般我们不会使用多阶段构建,因为本质上只要装好依赖复制好脚本代码就行了.

一般来说只要不涉及c扩展都是相当好处理的,官方给出的镜像哪个最小就用哪个(一般还是`alpine`版本的最小),但如果涉及到c扩展,还是应该选择使用`slim`版本.

以pyhton为例,`alpine`版本`14m至16m`,`slim`版本`40m左右`.一般来说我们还是以`slim`版本为主,因为一来一般高性能的依赖都是c扩展的,二来我们很难预测后续会不会要使用c扩展的依赖.